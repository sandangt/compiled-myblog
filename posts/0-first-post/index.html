<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>My First Post - JVM | San Dang's note</title>
<meta name=keywords content="java"><meta name=description content="This is my first post so nothing much, I'm talking about JVM but the goal is plain text testing"><meta name=author content="sandangt"><link rel=canonical href=https://lorem.sanlab.zone/posts/0-first-post/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://lorem.sanlab.zone/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lorem.sanlab.zone/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lorem.sanlab.zone/favicon-32x32.png><link rel=apple-touch-icon href=https://lorem.sanlab.zone/apple-touch-icon.png><link rel=mask-icon href=https://lorem.sanlab.zone/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://lorem.sanlab.zone/posts/0-first-post/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="My First Post - JVM"><meta property="og:description" content="This is my first post so nothing much, I'm talking about JVM but the goal is plain text testing"><meta property="og:type" content="article"><meta property="og:url" content="https://lorem.sanlab.zone/posts/0-first-post/"><meta property="og:image" content="https://lorem.sanlab.zone/img/posts/0-first-post/first-time-meme.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-18T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lorem.sanlab.zone/img/posts/0-first-post/first-time-meme.jpg"><meta name=twitter:title content="My First Post - JVM"><meta name=twitter:description content="This is my first post so nothing much, I'm talking about JVM but the goal is plain text testing"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://lorem.sanlab.zone/posts/"},{"@type":"ListItem","position":2,"name":"My First Post - JVM","item":"https://lorem.sanlab.zone/posts/0-first-post/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"My First Post - JVM","name":"My First Post - JVM","description":"This is my first post so nothing much, I'm talking about JVM but the goal is plain text testing","keywords":["java"],"articleBody":" source: wikipedia\nJVM is often considered the cornerstone of the Java programming language. It plays a critical role not only in executing Java programs but also in enabling cross-language interoperability and platform independence. Here’s something particularly interesting about the JVM:\nJust-In-Time (JIT) Compilation One of the most intriguing features of the JVM is its use of Just-In-Time (JIT) compilation. The JVM starts executing Java bytecode using an interpreter, which reads and executes one instruction at a time. However, as the program runs, the JVM analyzes the code and identifies “hot spots”—sections of code that are executed frequently.\nFor these hot spots, the JVM dynamically compiles the bytecode into native machine code, which is then executed directly by the CPU. This process is known as JIT compilation. The native code is stored and reused for future executions, which significantly improves the performance of the application over time.\nTwo Types of JIT Compilers\nThe JVM typically comes with two types of JIT compilers:\nC1 Compiler (Client Compiler): Optimizes code quickly with basic optimizations, focusing on reducing startup time and improving performance in scenarios where short-lived applications are common.\nC2 Compiler (Server Compiler): Performs more aggressive optimizations, suitable for long-running applications where startup time is less critical, but peak performance is essential.\nInterestingly, modern JVMs like HotSpot use a technique called Tiered Compilation, which combines the benefits of both C1 and C2 compilers. The JVM initially compiles code with the C1 compiler and, as the application runs longer and gathers more profiling data, it re-compiles the code with the C2 compiler for maximum optimization.\nAdaptive Optimization: Learning as It Goes The JVM doesn’t just compile code to native instructions blindly. It collects runtime information, such as the frequency of method invocations, types of objects, and branch predictions, to guide its optimization decisions. This ability to learn and adapt based on the running application’s behavior is what makes the JVM exceptionally powerful.\nFor instance, the JVM can inline frequently called methods, eliminate unnecessary bounds checks on arrays, or even remove code paths that are determined to be unreachable during runtime. This level of adaptive optimization enables Java applications to run close to the speed of native applications, despite being initially compiled to an intermediate form (bytecode).\nPolyglot Capabilities While the JVM was originally designed to run Java, it has evolved into a multi-language execution environment. Languages like Scala, Groovy, Kotlin, and Clojure all run on the JVM, leveraging its mature ecosystem and performance optimizations. Moreover, with tools like GraalVM, the JVM can even execute languages like Python, Ruby, and JavaScript.\nThis polyglot capability allows developers to choose the best language for a particular task while still benefiting from the JVM’s robust performance, garbage collection, and rich library support.\nThe JVM Ecosystem The JVM is more than just a runtime environment; it’s at the heart of a vast ecosystem that includes build tools (like Maven and Gradle), testing frameworks (like JUnit and TestNG), and application servers (like Tomcat and Jetty). This ecosystem has grown to support enterprise-scale applications, big data processing (with frameworks like Hadoop and Spark), and even microservices architectures with tools like Spring Boot and Micronaut.\nConclusion The JVM’s ability to execute code efficiently through JIT compilation and adaptive optimization, coupled with its support for multiple languages, makes it a unique and powerful platform. It has played a pivotal role in making Java one of the most popular and enduring programming languages, and its influence continues to grow as the JVM ecosystem expands into new areas like cloud computing and artificial intelligence.\n","wordCount":"589","inLanguage":"en","image":"https://lorem.sanlab.zone/img/posts/0-first-post/first-time-meme.jpg","datePublished":"2024-08-18T00:00:00Z","dateModified":"2024-08-18T00:00:00Z","author":{"@type":"Person","name":"sandangt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lorem.sanlab.zone/posts/0-first-post/"},"publisher":{"@type":"Organization","name":"San Dang's note","logo":{"@type":"ImageObject","url":"https://lorem.sanlab.zone/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lorem.sanlab.zone/ accesskey=h title="San Dang's note (Alt + H)">San Dang's note</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lorem.sanlab.zone/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://lorem.sanlab.zone/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://lorem.sanlab.zone/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://lorem.sanlab.zone/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">My First Post - JVM</h1><div class=post-description>This is my first post so nothing much, I'm talking about JVM but the goal is plain text testing</div><div class=post-meta><span title='2024-08-18 00:00:00 +0000 UTC'>Sunday, 18 August, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;sandangt</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#just-in-time-jit-compilation>Just-In-Time (JIT) Compilation</a></li><li><a href=#adaptive-optimization-learning-as-it-goes>Adaptive Optimization: Learning as It Goes</a></li><li><a href=#polyglot-capabilities>Polyglot Capabilities</a></li><li><a href=#the-jvm-ecosystem>The JVM Ecosystem</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p><img loading=lazy src=/img/posts/0-first-post/jvm-arch.png alt="JVM architecture">
<em>source: wikipedia</em></p><p>JVM is often considered the cornerstone of the Java programming language. It plays a critical role not only in executing Java programs but also in enabling cross-language interoperability and platform independence. Here’s something particularly interesting about the JVM:</p><h2 id=just-in-time-jit-compilation>Just-In-Time (JIT) Compilation</h2><p>One of the most intriguing features of the JVM is its use of Just-In-Time (JIT) compilation. The JVM starts executing Java bytecode using an interpreter, which reads and executes one instruction at a time. However, as the program runs, the JVM analyzes the code and identifies &ldquo;hot spots&rdquo;—sections of code that are executed frequently.</p><p>For these hot spots, the JVM dynamically compiles the bytecode into native machine code, which is then executed directly by the CPU. This process is known as JIT compilation. The native code is stored and reused for future executions, which significantly improves the performance of the application over time.</p><p><strong>Two Types of JIT Compilers</strong></p><p>The JVM typically comes with two types of JIT compilers:</p><ul><li><p>C1 Compiler (Client Compiler): Optimizes code quickly with basic optimizations, focusing on reducing startup time and improving performance in scenarios where short-lived applications are common.</p></li><li><p>C2 Compiler (Server Compiler): Performs more aggressive optimizations, suitable for long-running applications where startup time is less critical, but peak performance is essential.</p></li></ul><p>Interestingly, modern JVMs like HotSpot use a technique called Tiered Compilation, which combines the benefits of both C1 and C2 compilers. The JVM initially compiles code with the C1 compiler and, as the application runs longer and gathers more profiling data, it re-compiles the code with the C2 compiler for maximum optimization.</p><h2 id=adaptive-optimization-learning-as-it-goes>Adaptive Optimization: Learning as It Goes</h2><p>The JVM doesn’t just compile code to native instructions blindly. It collects runtime information, such as the frequency of method invocations, types of objects, and branch predictions, to guide its optimization decisions. This ability to learn and adapt based on the running application&rsquo;s behavior is what makes the JVM exceptionally powerful.</p><p>For instance, the JVM can inline frequently called methods, eliminate unnecessary bounds checks on arrays, or even remove code paths that are determined to be unreachable during runtime. This level of adaptive optimization enables Java applications to run close to the speed of native applications, despite being initially compiled to an intermediate form (bytecode).</p><h2 id=polyglot-capabilities>Polyglot Capabilities</h2><p>While the JVM was originally designed to run Java, it has evolved into a multi-language execution environment. Languages like Scala, Groovy, Kotlin, and Clojure all run on the JVM, leveraging its mature ecosystem and performance optimizations. Moreover, with tools like GraalVM, the JVM can even execute languages like Python, Ruby, and JavaScript.</p><p>This polyglot capability allows developers to choose the best language for a particular task while still benefiting from the JVM’s robust performance, garbage collection, and rich library support.</p><h2 id=the-jvm-ecosystem>The JVM Ecosystem</h2><p>The JVM is more than just a runtime environment; it’s at the heart of a vast ecosystem that includes build tools (like Maven and Gradle), testing frameworks (like JUnit and TestNG), and application servers (like Tomcat and Jetty). This ecosystem has grown to support enterprise-scale applications, big data processing (with frameworks like Hadoop and Spark), and even microservices architectures with tools like Spring Boot and Micronaut.</p><h2 id=conclusion>Conclusion</h2><p>The JVM’s ability to execute code efficiently through JIT compilation and adaptive optimization, coupled with its support for multiple languages, makes it a unique and powerful platform. It has played a pivotal role in making Java one of the most popular and enduring programming languages, and its influence continues to grow as the JVM ecosystem expands into new areas like cloud computing and artificial intelligence.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://lorem.sanlab.zone/tags/java/>Java</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>